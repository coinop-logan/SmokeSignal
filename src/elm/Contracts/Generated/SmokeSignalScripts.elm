module Contracts.Generated.SmokeSignalScripts exposing
    ( GetBulkAccounting
    , getBulkAccounting
    , getBulkAccountingDecoder
    )

import Eth.Abi.Decode as D exposing (abiDecode, andMap, data, toElmDecoder, topic)
import Eth.Abi.Encode as E exposing (Encoding(..), abiEncode)
import BigInt exposing (BigInt)
import Eth.Types exposing (..)
import Eth.Utils as U
import Json.Decode as Decode exposing (Decoder, succeed)
import Json.Decode.Pipeline exposing (custom)



{-

   This file was generated by https://github.com/cmditch/elm-ethereum-generator v4.0.0
   Compatible with elm-ethereum v4.0.0

-}
-- getBulkAccounting(address,bytes32[]) function


type alias GetBulkAccounting =
    { firstAuthorArray : List (Address)
    , nativeBurnedArray : List (BigInt)
    , dollarsBurnedArray : List (BigInt)
    , nativeTippedArray : List (BigInt)
    , dollarsTippedArray : List (BigInt)
    }


getBulkAccounting : Address -> Address -> List (Hex) -> Call GetBulkAccounting
getBulkAccounting contractAddress smokeSignal_ messageIds_ =
    { to = Just contractAddress
    , from = Nothing
    , gas = Nothing
    , gasPrice = Nothing
    , value = Nothing
    , data = Just <| E.functionCall "0e462286" [ E.address smokeSignal_, (E.list << List.map (E.staticBytes 32)) messageIds_ ]
    , nonce = Nothing
    , decoder = getBulkAccountingDecoder
    }


getBulkAccountingDecoder : Decoder GetBulkAccounting
getBulkAccountingDecoder =
    abiDecode GetBulkAccounting
        |> andMap (D.dynamicArray D.address)
        |> andMap (D.dynamicArray D.uint)
        |> andMap (D.dynamicArray D.uint)
        |> andMap (D.dynamicArray D.uint)
        |> andMap (D.dynamicArray D.uint)
        |> toElmDecoder


